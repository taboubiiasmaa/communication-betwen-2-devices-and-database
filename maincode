import tkinter as tk
from tkinter import filedialog, messagebox
import sqlite3
import shutil
import threading
import subprocess
import socket
import os
from PIL import Image, ImageTk

def on_code_scanné(event):
    code_barres = entry_code.get()  # Obtenir le code-barres saisi
    result_label.config(text=f"Quantité demandée: {code_barres}")
    entry_code.delete(0, tk.END)  # Effacer le champ après traitement

    # Fonction d'exportation des données vers le fichier
def export_data_to_file():
    try:
        conn = sqlite3.connect('mydatabase.db')
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM produits")
        rows = cursor.fetchall()
        conn.close()
        if rows:
            with open('extract.txt', 'w') as file:
                for row in rows:
                    file.write(f"ID: {row[0]}, Nom: {row[1]}, Quantité: {row[2]}\n")
            messagebox.showinfo("Succès", "Les données ont été exportées avec succès dans 'extract.txt'.")
        else:
            messagebox.showwarning("Aucune donnée", "Aucune donnée à exporter.")
    except Exception as e:
        messagebox.showerror("Erreur", f"Erreur lors de l'exportation des données : {e}")       
# Fonction pour ouvrir le fichier exporté et l'afficher
def open_file():
    filepath = filedialog.askopenfilename(filetypes=[("Text files", "*.txt")])
    if filepath:
        with open(filepath, 'r') as file:
            lines = file.readlines()

        if lines:
            data_display = "\n".join(lines)
            messagebox.showinfo("Contenu du Fichier", data_display)
        else:
            messagebox.showwarning("Fichier Vide", "Le fichier est vide.")
    else:
        messagebox.showwarning("Erreur", "Aucun fichier sélectionné.")
def save_to_database(identite, quantite):
    try:
        conn = sqlite3.connect('mydatabase.db')
        cursor = conn.cursor()
        cursor.execute('''INSERT INTO produits (nom, quantite) VALUES (?, ?)''', (identite, quantite))
        conn.commit()
        conn.close()
        messagebox.showinfo("Succès", f"Produit '{identite}' ajouté avec une quantité de {quantite}.")
    except Exception as e:
        messagebox.showerror("Erreur", f"Erreur lors de l'enregistrement dans la base de données : {e}")
def create_database_and_open_window():
    try:
        conn = sqlite3.connect('mydatabase.db')
        cursor = conn.cursor()
        # Création de la table si elle n'existe pas
        cursor.execute('''CREATE TABLE IF NOT EXISTS produits (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            nom TEXT NOT NULL,
                            quantite INTEGER NOT NULL
                        )''')
        conn.commit()
        conn.close()
        # Ouvrir la fenêtre pour ajouter un produit
        open_add_product_window()
    except Exception as e:
        messagebox.showerror("Erreur", f"Erreur lors de la création de la base de données : {e}")
def open_add_product_window():
    add_product_window = tk.Toplevel(root)  # Crée une nouvelle fenêtre
    add_product_window.title("Ajouter un Produit")
    add_product_window.geometry("300x300")
    # Labels et entrées pour l'identité et la quantité
    tk.Label(add_product_window, text="Ident :").pack(pady=5)
    entry_identite = tk.Entry(add_product_window)
    entry_identite.pack(pady=5)
    tk.Label(add_product_window, text="Quantité :").pack(pady=5)
    entry_quantite = tk.Entry(add_product_window)
    entry_quantite.pack(pady=5)
    # Bouton pour enregistrer le produit
    def save_product():
        identite = entry_identite.get()
        quantite = entry_quantite.get()
        if not identite or not quantite.isdigit():
            messagebox.showerror("Erreur", "Veuillez entrer une identité valide et une quantité numérique.")
            return
        save_to_database(identite, int(quantite))
        entry_identite.delete(0, tk.END)
        entry_quantite.delete(0, tk.END)
    save_button = tk.Button(add_product_window, text="Enregistrer les données", command=save_product)
    save_button.pack(pady=10)
    # Bouton pour visualiser les données
    visualize_button = tk.Button(add_product_window, text="Visualiser les Données",  command=visualize_data)
    visualize_button.pack(pady=10)
def visualize_data():
    try:
        conn = sqlite3.connect('mydatabase.db')
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM produits")
        rows = cursor.fetchall()
        conn.close()
        # Ouvrir une nouvelle fenêtre pour afficher les données
        visualize_window = tk.Toplevel(root)
        visualize_window.title("Visualiser les Données")
        visualize_window.geometry("400x300")
        # Créer une liste pour afficher les données
        data_listbox = tk.Listbox(visualize_window)
        data_listbox.pack(expand=True, fill=tk.BOTH)
        # Ajouter les données à la liste
        for row in rows:
            data_listbox.insert(tk.END, f"ID: {row[0]}, Nom: {row[1]}, Quantité: {row[2]}")
        # Bouton pour sélectionner l'identité
        def select_ident():
            # Ouvrir une nouvelle fenêtre pour saisir manuellement l'identifiant
            ident_window = tk.Toplevel(visualize_window)
            ident_window.title("Saisir Identifiant")
            ident_window.geometry("300x150")
            tk.Label(ident_window, text="Entrez l'identifiant (Nom) :").pack(pady=5)
            entry_ident = tk.Entry(ident_window)
            entry_ident.pack(pady=5)
            def fetch_quantity():
                ident = entry_ident.get()
                if not ident:
                    messagebox.showwarning("Erreur", "Veuillez entrer un identifiant valide.")
                    return
                # Rechercher la quantité associée à cet identifiant dans la base de données
                try:
                    conn = sqlite3.connect('mydatabase.db')
                    cursor = conn.cursor()
                    cursor.execute("SELECT quantite FROM produits WHERE nom = ?", (ident,))
                    result = cursor.fetchone()
                    conn.close()
                    if result:
                        messagebox.showinfo("Quantité trouvée", f"Le produit '{ident}' a une quantité de {result[0]}")
                    else:
                        messagebox.showwarning("Erreur", f"Aucun produit trouvé avec l'identifiant '{ident}'")

                except Exception as e:
                    messagebox.showerror("Erreur", f"Erreur lors de la récupération des données : {e}")
                ident_window.destroy()
            fetch_button = tk.Button(ident_window, text="Rechercher", command=fetch_quantity)
            fetch_button.pack(pady=10)
        select_button = tk.Button(visualize_window, text="Sélectionner Ident", command=select_ident)
        select_button.pack(pady=10)
        # Bouton pour supprimer l'identité
        def open_delete_name_window():
            delete_name_window = tk.Toplevel(visualize_window)
            delete_name_window.title("Supprimer un Produit")
            delete_name_window.geometry("300x150")
            tk.Label(delete_name_window, text="Entrez le nom (Ident )à supprimer :").pack(pady=5)
            entry_delete_name = tk.Entry(delete_name_window)
            entry_delete_name.pack(pady=5)
            def confirm_deletion():
                product_name = entry_delete_name.get()
                if not product_name:
                    messagebox.showerror("Erreur", "Veuillez entrer un nom valide.")
                    return
                # Supprimer le produit de la base de données
                try:
                    conn = sqlite3.connect('mydatabase.db')
                    cursor = conn.cursor()
                    cursor.execute("DELETE FROM produits WHERE nom = ?", (product_name,))
                    conn.commit()
                    if cursor.rowcount == 0:
                        messagebox.showwarning("Erreur", f"Aucun produit trouvé avec le nom (Ident) '{product_name}'.")
                    else:
                        messagebox.showinfo("Succès", f"Produit avec le nom (Ident) '{product_name}' supprimé.")
                    conn.close()
                    delete_name_window.destroy()  # Fermer la fenêtre de suppression
                    visualize_data()  # Mettre à jour la liste après suppression
                except Exception as e:
                    messagebox.showerror("Erreur", f"Erreur lors de la suppression : {e}")
            delete_button = tk.Button(delete_name_window, text="Supprimer", command=confirm_deletion)
            delete_button.pack(pady=10)
        delete_button = tk.Button(visualize_window, text="Supprimer par Nom(Ident) ", command=open_delete_name_window)
        delete_button.pack(pady=10)
    except Exception as e:
        messagebox.showerror("Erreur", f"Erreur lors de la récupération des données : {e}")

# Chemin du fichier texte (modifiez ce chemin selon votre dossier)
text_file_path = os.path.expanduser("/home/pi/interface /Stat/Nouveau2.txt")

# Fonction pour lire le fichier texte et mettre à jour les labels
def update_labels_once():
    if os.path.exists(text_file_path):
        with open(text_file_path, 'r') as file:
            lines = file.readlines() 
            conforme_count = 0
            non_conforme_count = 0
            # Parcourir chaque ligne pour compter les messages
            for line in lines:
                parts = line.strip().split()
                if len(parts) >= 4:  # S'assurer qu'il y a au moins quatre colonnes
                    if parts[6] == "DEFAUT:":
                        non_conforme_count += 1
                    elif (parts[6] == "no" and parts[7] == "error"):
                        conforme_count += 1
            # Mettre à jour les labels avec les résultats
            label1.config(text="Produit conforme : " + str(conforme_count))
            label2.config(text="Produit non conforme : " + str(non_conforme_count))
    else:
        label1.config(text="Fichier non trouvé")
        label2.config(text="Veuillez vérifier le chemin")

# Fonction pour ouvrir et lire un fichier texte
def open_file():
    filepath = filedialog.askopenfilename(filetypes=[("Text files", "*.txt")])
    if filepath:
        with open(filepath, 'r') as file:
            lines = file.readlines()
            if len(lines) >= 2:
                label1.config(text="Produit conforme : " + lines[0].strip())
                label2.config(text="Produit non conforme : " + lines[1].strip())
            else:
                label1.config(text="Fichier incomplet")
                label2.config(filepath = filedialog.askopenfilename(filetypes=[("Text files", "*.txt")]))

# Fonction de gestion de l'événement de saisie du code-barres
def on_code_scanné1(event):

    code_barres = entry_code.get()
    quantity = entry_quantity.get()
    print(f"Code-barres: '{code_barres}', Quantité: '{quantity}'")  # Débogage
    if code_barres and quantity.isdigit():
        result_label.config(text=f"Quantité demandée: {quantity} pour Ident: {code_barres}")
        entry_code.delete(0, tk.END)
        entry_quantity.delete(0, tk.END)
    else:
        messagebox.showerror("Erreur", "Veuillez entrer une quantité valide.")
    # code_barres = entry_code.get()  # Lire le code-barres depuis l'entrée
    # if code_barres:
      #   result_label.config(text=f"Quantité demandée: {code_barres}")
      #   entry_code.delete(0, tk.END)  # Effacer le champ après traitement

# Interface principale
root = tk.Tk()
root.title("Statistique journalière")
root.geometry("1000x1000")

# Charger l'image de départ
image_link = "/home/pi/projet2/image/rename2.png"
image = Image.open(image_link)
resize_image = image.resize((350, 150))
photo = ImageTk.PhotoImage(resize_image)
affiche_image = tk.Label(root, image=photo)
affiche_image.pack()
# Zone pour afficher une autre image
image_label = tk.Label(root)
image_label.pack()
# Bouton pour ouvrir et lire un fichier texte
file_button = tk.Button(root, text="Ouvrir le Stat", command=open_file)
file_button.pack()
# Zone pour saisir le code-barres (simuler la saisie clavier)
entry_code = tk.Entry(root, width=40)
entry_code.pack(pady=20, ipadx=10, ipady=12)
entry_code.bind("<Return>", on_code_scanné1)
# Label pour afficher le résultat du code-barres
result_label = tk.Label(root, text="Quantité demandée: ", font=("Helvetica", 16))
result_label.pack(pady=20)
# Labels pour afficher les données extraites du fichier texte
label1 = tk.Label(root, text="Produit conforme :", font=("Helvetica", 20), padx=38.2, pady=20, bg="green")
label1.pack()
espace = tk.Label(root, text="  ")
espace.pack()
label2 = tk.Label(root, text="Produit non conforme :", font=("Helvetica", 20), padx=20, pady=20, bg="red")
label2.pack()
# Bouton pour créer la base de données et ouvrir la fenêtre d'ajout de produit
db_button = tk.Button(root, text="Créer Base de Données", font=("Helvetica", 20), bg="green", command=create_database_and_open_window)
db_button.pack(pady=10)
# Bouton pour exporter les données vers le fichier extract.txt
export_button = tk.Button(root, text="Exporter Données vers Fichier", command=export_data_to_file)
export_button.pack(pady=10)
# Lancer la mise à jour des labels une seule fois
update_labels_once()
# Fonction pour envoyer le code-barres sous forme de message
def send_code_to_remote_machine(code_barres, ip, quantity, port=12345):
    try:
        # Créer un socket TCP
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((ip, port))  # Se connecter à l'adresse IP et au port
            message = f"Ident reçu: {code_barres}, Quantité demandée: {quantity}"  # Créer le message à envoyer
            s.sendall(message.encode('utf-8'))  # Envoyer le message
            print(f"Message '{message}' envoyé à {ip}:{port}")
            messagebox.showinfo("Succès", f"Message envoyé à {ip}:{port}")
    except Exception as e:
        messagebox.showerror("Erreur", f"Erreur lors de l'envoi du message à {ip}: {e}")
# Fonction appelée lorsqu'un code-barres est scanné et doit être envoyé
def on_code_scanné():
    code_barres = entry_code.get()  # Obtenir le code-barres saisi
    remote_ip = entry_ip.get()  # Obtenir l'adresse IP de la machine distante
    quantity = entry_quantity.get()  # Obtenir la quantité demandée
    # Vérifications des champs
    if not code_barres:
        messagebox.showerror("Erreur", "Veuillez entrer un Ident.")
        return
    if not remote_ip:
        messagebox.showerror("Erreur", "Veuillez entrer une adresse IP.")
        return
    if not quantity:
        messagebox.showerror("Erreur", "Veuillez entrer une quantité.")
        return
    # Mettre à jour l'étiquette de résultat
    result_label.config(text=f"Quantité demandée: {quantity} pour Ident: {code_barres}")
    # Effacer les champs après traitement
    entry_code.delete(0, tk.END)
    entry_quantity.delete(0, tk.END)
    # Envoyer le message contenant le code-barres et la quantité à la machine distante
    send_code_to_remote_machine(code_barres, remote_ip, quantity)
# Exemple d'interface Tkinter
root = tk.Tk()
root.title("Envoi Ident")
# Champ pour le code-barres
label_code = tk.Label(root, text="Ident:")
label_code.pack()
entry_code = tk.Entry(root)
entry_code.pack()
# Champ pour l'adresse IP
label_ip = tk.Label(root, text="Adresse IP:")
label_ip.pack()
entry_ip = tk.Entry(root)
entry_ip.pack()
# Champ pour la quantité
label_quantity = tk.Label(root, text="Quantité:")
label_quantity.pack()
entry_quantity = tk.Entry(root)
entry_quantity.pack()
# Étiquette pour afficher le résultat
result_label = tk.Label(root, text="")
result_label.pack()
# Bouton pour envoyer le message
button_send = tk.Button(root, text="Envoyer", command=on_code_scanné)
button_send.pack()
root.mainloop()
